# Домашнее задание к занятию 11.2 «Микросервисы: принципы»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.

### Решение задачи 1

Решения для обеспечения реализации API Gateway:

| Решение | Маршрутизация запросов | Аутентификация | Терминация HTTPS | Бесплатно/Открыто? |
|---|---|---|---|---|
| Amazon AWS API Gateway | + | + | ? ( требуется наличие самоподписанного SSL-сертификата) | Платно |
| Apache APISIX | + | + | + | Бесплатно |
| Azure API Gateway | + | + | + | Платно |
| Google APIGee | + | + | + | Платно |
| HAProxy | + | + | + | Бесплатно |
| Kong | + | + | + | Бесплатно |
| KrakenD | + | + | + | Нужные функции в платной версии |
| NGINX | + | + | + | Бесплатно |
| NGINX Plus | + | + | + | Платно |
| Tyk.io | + | + | + | Бесплатно |

В принципе, все перечисленные решения соответствуют вышеуказанным требованиям. Если компания намерена размещать инфраструктуру в облачной среде, то оптимальным видится использование Google APIGee (или в современных реалиях Yandex API Gateway). Если инфраструктура является локальной, то интересным видится решение с открытым исходным кодом Kong, так как это широко распространенное бесплатное решение, построенное на базе NGINX, имеющее различные схемы реализации API Gateway и поддерживаемое большим сообществом специалистов. 

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.

### Решение задачи 2

Решения для обеспечения реализации брокеров сообщений:

| Брокер                                                | ActiveMQ | Apollo | Kafka | RabbitMQ | Redis |
|-------------------------------------------------------|:--------:|:------:|:-----:|:--------:|:-----:|
| Поддержка кластеризации для обеспечения надежности    | +        | -      | +     | +        | +     |
| Хранение сообщений на диске в процессе доставки       | +        | +      | +     | +        | -     |
| Высокая скорость работы                               | -        | -      | +     | +        | +     |
| Поддержка различных форматов сообщений                | +        | +      | +     | +        | +     |
| Разделение прав доступа к различным потокам сообщений | +        | +      | +     | +        | +     |
| Простота эксплуатации                                 | +        | +      | -     | +        | +     |

Лучшими вариантами видятся Kafka или RabbitMQ. У каждого из этих решений есть свои особенности, которые могут стать ключевыми при выборе одного из них:

- Kafka - обеспечивает очень высокую производительность. Имеет распределенную очередь с высокой пропускной способностью, адаптированную для длительного хранения больших объемов данных. Решение от Kafka более сложное в настройке и эксплуатации. Брокер Kafka хорошо подходит для анализа данных (отслеживание, прием данных, ведение журнала, обеспечение безопасности).

- RabbitMQ - широко применяемый и популярный брокер сообщений с множеством функций и возможностей, поддерживающих сложную маршрутизацию. Обеспечивает эффективную маршрутизацию сообщений при не таком значительном трафике, как в Kafka. Брокер RabbitMQ хорошо подходит, если нужен просто посредник между сервисами в микросервисной архитектуре. Поддерживает приоритизацию сообщений.

